import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RMIServerSocketFactory;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;

public class AddClass extends UnicastRemoteObject implements AddInterface {
	
	private int serverPort;
	
	private static int MTL = 6770;
	private static int LVL = 6880;
	private static int DDO = 6990;
	
	private HashMap<Character, HashMap<String, Record>> records = new HashMap<Character, HashMap<String, Record>>();
	private HashMap<String, TRecord> Tfiles = new HashMap<String, TRecord>();
    private HashMap<String, SRecord> Sfiles = new HashMap<String, SRecord>();
       
    private LinkedList<String> TFieldName = new LinkedList<String>(Arrays.asList("address", "phone", "location"));
    private LinkedList<String> SFieldName = new LinkedList<String>(Arrays.asList("courseregistered", "status", "statusdate"));
    private ArrayList<String> IDPackage = new ArrayList<String>();
    private ArrayList<TRecord> TRecPackage = new ArrayList<TRecord>();
    private ArrayList<SRecord> SRecPackage = new ArrayList<SRecord>();
    
    
	public AddClass(int n) throws Exception {
		serverPort = n;
	}

	
	
	
    private int count = 0;
	
	private int[] otherPorts;
	
	public AddClass() throws RemoteException {

		otherPorts = new int[2];
	}
	
	public void setPorts(int s1, int s2) throws RemoteException {
		otherPorts[0] = s1;
		otherPorts[1] = s2;
	}
	
	private String requestCounts(int port) {
		DatagramSocket aSocket = null;
		String ans = null;
		
		try {
			aSocket = new DatagramSocket();
			String message = "count";
			
			byte[] m = message.getBytes();
			InetAddress aHost = InetAddress.getByName("localhost");

			DatagramPacket request = new DatagramPacket(m, message.length(), aHost, port);
			aSocket.send(request);

			byte[] buffer = new byte[1000];
			DatagramPacket reply = new DatagramPacket(buffer, buffer.length);
			aSocket.receive(reply);
			ans = new String(reply.getData());
		} catch (SocketException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {
			if (aSocket != null) {
				aSocket.close();
			}
		}
		return ans;
	}

	@Override
	public void increment() throws RemoteException {
		count++;
	}

	@Override
	public String getCounts() throws RemoteException {
		String counts = "This server: " + Integer.toString(getCount());
		
		counts = counts + ", Server 2: " + requestCounts(otherPorts[0]).trim();
		counts = counts + ", Server 3: " + requestCounts(otherPorts[1]).trim();
		
		return counts;
	}

	@Override
	public int getCount() {
		return IDPackage.size();
	}

	public String getID(boolean isTeacher) {
		String id = "";
		
		if (isTeacher) {
			id = "TR";
			String formatted = String.format("%05d", TRecPackage.size());
			id = id + formatted;
			while(IDPackage.contains(id)){
				id = "TR";
				id = id + String.format("%05d", TRecPackage.size()+1);
			}
			
			IDPackage.add(id);
			
		} else {
			id = "SR";
			String formatted = String.format("%05d", SRecPackage.size());
			id = id + formatted;
			while(IDPackage.contains(id)){
				id = "SR";
				id = id + String.format("%05d", SRecPackage.size()+1);
			}
			
			IDPackage.add(id);
		}
		
		return id;
	}

	public void createTRecord(String first, String last, String address, String phone, String specialization, String location) {
		synchronized (this){
			TRecord teacher = new TRecord(first, last, specialization);
				teacher.setAddress(address);
				teacher.setLocation(location);
				teacher.setPhone(phone);
		        LinkedList <String> r = teacher.combineAll();
		        
				String lastTemp = last.toUpperCase().trim();
				Character firstLetter = lastTemp.charAt(0);
				
				HashMap<String, Record> file = new HashMap<String, Record>();
		        String TID = getID(true);
		        file.put(TID, teacher);
		        Tfiles.put(TID, teacher);
		        TRecPackage.add(teacher);
		        records.put(firstLetter, file);
		        System.out.println("There is a newly created TRecord: " + TID);
		        System.out.println("With Record information following: " +r.toString());
		        System.out.println("size is " + IDPackage.size());
		        System.out.println(IDPackage.toString());
		}
		
	}

	public void createSRecord(String first, String last, String courseRegistered, String status, String statusDate) {
		synchronized (this){
			    SRecord student = new SRecord(first, last);
				String lastTemp = last.toUpperCase().trim();
		        Character firstLetter = lastTemp.charAt(0);
				
	            student.addCourse(courseRegistered);
	            student.setStatus(status);
	            student.setDate(statusDate);
	            LinkedList <String> r = student.combineAll();
	
		        HashMap<String, Record> file = new HashMap<String, Record>();
	            String SID = getID(false);
		        file.put(SID, student);         
	            Sfiles.put(SID, student);
	            SRecPackage.add(student);
	            records.put(firstLetter, file);
	            System.out.println("There is a newly created SRecord: " + SID);
	            System.out.println("With Record information following: " +r.toString());
		}        
	}

/*	
	public int getCount(){
		return IDPackage.size();
	}
	*/
	
	public void getRecordCounts(){
		if(serverPort == MTL){
			UDPClient client_MTL = new UDPClient(LVL+1,DDO+1);
            UDPServer server_LVL = new UDPServer(LVL+1);
			UDPServer2 server_DDO = new UDPServer2(DDO+1);
			
			server_LVL.run();
			server_DDO.run();
			System.out.println("Servers are listening");
			try {
				wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			client_MTL.run();
		}
		if(serverPort == LVL){
			UDPClient client_LVL = new UDPClient(MTL+2,DDO+2);
            UDPServer server_MTL = new UDPServer(MTL+2);
			UDPServer server_DDO = new UDPServer(DDO+2);
			
			server_MTL.run();
			server_DDO.run();
			System.out.println("Servers are listening");
			try {
				wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			client_LVL.run();
		}
		if(serverPort == DDO){
			UDPClient client_DDO = new UDPClient(MTL+3,LVL+3);
            UDPServer server_MTL = new UDPServer(MTL+3);
			UDPServer server_LVL = new UDPServer(LVL+3);
			
			server_MTL.run();
			server_LVL.run();
			System.out.println("Servers are listening");
			try {
				wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			client_DDO.run();
		}
		else{
			System.out.println("There is no valid CenterServer to get record counts!!");
		}
	}
	

	public void editRecord(String recordID, String fieldName, String newValue) {
		
                if(IDPackage.contains(recordID)){
                    if(recordID.startsWith("TR")){
                        if(TFieldName.contains(fieldName.toLowerCase())){
                        	  TRecord TRec = Tfiles.get(recordID);
                              String last = TRec.getLastName();
                              
                                  if(fieldName.toLowerCase().equals(TFieldName.get(0))){
                                      TRec.setAddress(newValue);
                                  }
                                  if(fieldName.toLowerCase().equals(TFieldName.get(1))){
                                      TRec.setPhone(newValue);
                                  }
                                  if(fieldName.toLowerCase().equals(TFieldName.get(2))){
                                      TRec.setLocation(newValue);
                                  }
                                  
                              records.get(last.charAt(0)).put(recordID, TRec);
                              System.out.println("Edited Record information following: " + TRec.combineAll().toString()); 
                              Tfiles.put(recordID, TRec);
                        }
                              else{
                                  System.out.println("Teacher Records do not have such Field Name: " + fieldName);
                              }
                          }
               
                    if(recordID.startsWith("SR")){
                        if(SFieldName.contains(fieldName.toLowerCase())){
                            
                            SRecord SRec = Sfiles.get(recordID);
                            String last = SRec.getLastName();
                            
                                if(fieldName.toLowerCase().equals(SFieldName.get(0))){
                                    SRec.addCourse(newValue);
                                }
                                if(fieldName.toLowerCase().equals(SFieldName.get(1))){
                                    SRec.setStatus(newValue);
                                }
                                if(fieldName.toLowerCase().equals(SFieldName.get(2))){
                                    SRec.setDate(newValue);
                                }
                                records.get(last.charAt(0)).put(recordID, SRec);//to update the changed SRecord in records.  
                                Sfiles.put(recordID, SRec);
                                LinkedList <String> r = SRec.combineAll();
                                System.out.println("Edited Record information following: " + newValue);
                            }
                            else{
                                System.out.println("Student Records do not have such Field Name: " + fieldName);
                            }
                        }
                }
                else{
                    System.out.println("There is no such Record ID: " + recordID) ;
                }
    }
}
